{
  "hash": "479b7366de281f437e5dc6568c35fe9d",
  "result": {
    "markdown": "---\ntitle: \"Julia macros for beginners\"\ndate: 2021-06-07\ncategories: [\"julia\"]\n---\n\nMacros are a powerful and interesting feature of the Julia programming language, but they can also be confusing.\nUsers coming from Python, Matlab or R have not come in contact with similar constructs before, and they require a different way of thinking about code.\nThis article is supposed to be a simple introduction, after which you might judge better when use of macros is appropriate and how to get around some of the most common gotchas.\n\n## What are macros for?\n\nMacros change existing source code or generate entirely new code.\nThey are not some kind of more powerful function that unlocks secret abilities of Julia, they are just a way to automatically write code that you could have written out by hand anyway.\nThere's just the question whether writing that code by hand is practical, not if it's possible.\nOften, we can save users a lot of work, by hiding boilerplate code they would otherwise need to write inside our macro.\n\nStill, it's good advice, especially for beginners, to think hard if macros are the right tool for the job, or if run-of-the-mill functions serve the same purpose.\nOften, functions are preferable because macro magic puts a cognitive burden on the user, it makes it harder to reason about what code does.\nBefore understanding the code, they have to understand the transformation that the macro is doing, which often goes hand in hand with non-standard syntax.\nThat is, unless they are ok with their code having unintended consequences.\n\n## What does a macro do?\n\nSome of the magic of macros derives from the fact that they don't just generate some predefined code, they rather take the code they are applied to and transform it in useful ways.\nVariable names are one of the fundamental mechanisms by which we make code understandable for humans.\nIn principle, you could replace every identifier in a working piece of code with something random, and it would still work.\n\n```julia\nprofit = revenue - costs\n# does the same thing as\nhey = whats - up\n```\nThe computer doesn't care about the names, only humans do.\nBut functions run after the code has been transformed into lower-level representations, and names are lost at that point.\n\nFor example, in this code snippet, there is no way for the author of the function to know what the user named their variable.\nThe function just receives a value, and as far as it is concerned, that value is named `x`.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction show_value(x)\n    println(\"The value you passed is \", x)\nend\n\norange = \"sweet\"\napple = \"sour\"\n\nshow_value(orange)\nshow_value(apple)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe value you passed is sweet\nThe value you passed is sour\n```\n:::\n:::\n\n\nAny information about what the user wrote is lost, as the function only knows \"sweet\" and \"sour\" were passed.\nIf we want to incorporate the information contained in the variable names, we need a macro.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nmacro show_value(variable)\n    quote\n        println(\"The \", $(string(variable)), \" you passed is \", $(esc(variable)))\n    end\nend\n\n@show_value(orange)\n@show_value(apple)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe orange you passed is sweet\nThe apple you passed is sour\n```\n:::\n:::\n\n\nYou probably know a macro that works very similar to this one, which is `@show`\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n@show orange\n@show apple\n```\n:::\n\n\nNote that it doesn't make a difference here if we use parentheses for the macros or not.\nThat's a feature of Julia's syntax which makes some macros more tidy to write.\nThis is especially true if the macro precedes a for block or some other multi-line expression.\n\n## How do macros work?\n\nLet's look at our macro in more detail. Even though it's short, it has a few interesting aspects to it.\n\nFirst of all, a macro runs before any code is executed.\nTherefore, you never have access to any runtime values in a macro.\nThat's something that trips many beginners up, but is crucial to understand.\nAll the logic in the macro has to happen only using the information you can get from the expressions that the macro is applied to.\n\nOne good step to understand what's going on with an expression, is to dump it.\nYou can use `Meta.@dump` for that.\n\nIn our case, it's not very interesting:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nMeta.@dump orange\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSymbol orange\n```\n:::\n:::\n\n\nAs you can see, the expression `orange` contains only the `Symbol` orange.\nSo that is what our macro gets as input, just `:orange`.\nBut, again, no runtime information about it being `\"sweet\"`.\n\nInside the macro, a `quote` expression is constructed.\nA `quote` with source code inside returns an expression object that describes this code.\nThe expression we return from a macro is spliced into the place where the macro call happens, as if you really had written the macro result there.\nThat's the reason why a macro can't technically do more than any old Julia code.\n\nWe can see the code that the macro call results in by using another helper macro, `@macroexpand`.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@macroexpand @show_value orange\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>quote\n    <span class=\"ansi-bright-black-fg\">#= In[3]:3 =#</span>\n    Main.println(\"The \", \"orange\", \" you passed is \", orange)\nend</pre>\n```\n:::\n\n:::\n:::\n\n\nYou can see that, ignoring linenumber and module information, the macro created a function call as if we had written\n\n```julia\nprintln(\"The \", \"orange\", \" you passed is \", orange)\n```\n\nTherefore, let's look at where the two oranges come from.\n\nThe first one is `\"orange\"`, which is a string literal.\nWe achieved this with this expression inside the macro:\n\n```julia\n$(string(variable))\n```\n\nRemember that `variable` holds the `Symbol` `:orange` when the macro is called.\nWe convert that to a string and then place that string into the quoted expression using the interpolation symbol `$`.\nThis is how we can print out a sentence that references the user's chosen variable name.\n\nThe other `orange` is just a normal variable name.\nIt was created with the interpolation expression `$(esc(variable))`.\nThe `esc` stands for `escape` and is another part of macros that is hard to understand for beginners.\n\n## What's escaping?\n\nTo explain why `esc` is needed, let's look at a macro that leaves it out.\nIn this example we define the macro in a separate module (because any macro you'd put in a package would not be in the `Main` module either):\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nmodule SomeModule\n    export @show_value_no_esc\n    macro show_value_no_esc(variable)\n        quote\n            println(\"The \", $(string(variable)), \" you passed is \", $variable)\n        end\n    end\nend\n\nusing .SomeModule\n\ntry\n    @show_value_no_esc(orange)\ncatch e\n    sprint(showerror, e)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n\"UndefVarError: `orange` not defined\"\n```\n:::\n:::\n\n\nThe code errors because there is no variable `orange`.\nBut there should be, we interpolated it right there!\nLet's look at the macro output with `@macroexpand` again:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n@macroexpand @show_value_no_esc(orange)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre>quote\n    <span class=\"ansi-bright-black-fg\">#= In[7]:5 =#</span>\n    Main.SomeModule.println(\"The \", \"orange\", \" you passed is \", Main.SomeModule.orange)\nend</pre>\n```\n:::\n\n:::\n:::\n\n\nOk, so the variable looked up is actually `SomeModule.orange`, and of course we didn't define a variable with that name in `SomeModule`.\nThe reason this happens is that macros do often need to reference values from whatever module they were defined in (for example, to add a helper function, that also lives in that module, to the user's code).\nAny variable name used in the created expression is looked up in the macro's parent module by default.\n\nThe other reason is that it is potentially dangerous to just change or create variables in user space in a macro that knows nothing about what's going on there.\n\nImagine the writer of the macro and the user as two people who know nothing about each other.\nThey only interface via the small snippet of code passed to the macro.\nSo, obviously, the macro shouldn't mess around with the user's variables.\n\nIn theory, a macro could insert things like `my_variable = nothing` or `empty!(some_array)` in the place where it's used.\nBut imagine the user already has a `my_variable` and it happens to hold the result of a computation that ran hours.\nAs the macro writer doesn't know anything about the variables the user has created, all macro-created variables are by default scoped to the macro's module to avoid conflicts.\n\nHere's a short example of bad escaping, with a macro that is not really supposed to do anything:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nmacro change_nothing(exp)\n    e = quote\n        temp_variable = nothing # this could be some intermediate computation\n        $exp # we actually just pass the input expression back unchanged\n    end\n    esc(e) # but everything is escaped\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n@change_nothing (macro with 1 method)\n```\n:::\n:::\n\n\n## a user who happens to have a temp variable calls this macro...\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\ntemp_variable = \"important information\"\nx = @change_nothing 1 + 1\n\n@show x\n@show temp_variable\n```\n:::\n\n\nWhoops, the `temp_variable` was overwritten by the macro, and this can happen with badly written macros.\n\nBut still, in order to access the value of the user's variable `orange`, we need to `escape` the use of that symbol in our generated expression.\nEscaping the variable could be summarized as saying \"treat this variable like a variable the user has written themselves\".\n\nAs a rule of thumb, macros should only ever escape variables that they know about because they were passed to the macro.\nThese are the variables that the user potentially wants to have changed by the macro, or at least they are aware that they could be subject to change.\n\nHere you can see another example, where there is both a user and a module `orange`:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\nmodule AnotherModule\n    export @show_value_user_and_module\n\n    orange = \"bitter\"\n\n    macro show_value_user_and_module(variable)\n        quote\n            println(\"The \", $(string(variable)), \" you passed is \", $(esc(variable)),\n                \" and the one from the module is \", $variable)\n        end\n    end\nend\n\nusing .AnotherModule\n\n@show_value_user_and_module orange\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe orange you passed is sweet and the one from the module is bitter\n```\n:::\n:::\n\n\n## Modifying expressions\n\nEven though we could already see some interesting macro properties, maybe you didn't start reading this article to learn about printing users their own variable names back (even though that is a very user friendly behavior in general, and many R users like their non-standard evaluation a lot for this reason).\n\nUsually, you want to modify the expression you receive, or build a new one with it, to achieve some functional purpose.\nSometimes, macros are used to define domain specific languages or DSLs, that allow users to specify complex things with simple, yet non-standard expressions.\n\nA good example for this are the formulas from `StatsModels.jl`, where `@formula(y ~ x)` is a nice shortcut to create a formula object that you could in principle build yourself without a macro, but with much more typing.\n\nLet's try to write a small useful macro that transforms a real expression!\n\nAn issue some Julia users face once in a while is that the `fill` function's argument is executed once, and then the whole vector is filled with that result.\nLet's say we want a vector of 5 three-element random vectors.\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\nrand_vec = fill(rand(3), 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n5-element Vector{Vector{Float64}}:\n [0.9039841821218482, 0.3644507708511703, 0.8407975367191795]\n [0.9039841821218482, 0.3644507708511703, 0.8407975367191795]\n [0.9039841821218482, 0.3644507708511703, 0.8407975367191795]\n [0.9039841821218482, 0.3644507708511703, 0.8407975367191795]\n [0.9039841821218482, 0.3644507708511703, 0.8407975367191795]\n```\n:::\n:::\n\n\nAs you can see, every vector is the same, which we don't want.\nA way to get our desired result is with a list comprehension:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nrand_vec = [rand(3) for _ in 1:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n5-element Vector{Vector{Float64}}:\n [0.8957367680265885, 0.249510539903665, 0.8937505345144938]\n [0.9314953138974689, 0.25762719951419766, 0.15016666804238443]\n [0.27431927403854617, 0.16696200453179322, 0.18711308743600819]\n [0.15334416897527525, 0.09403493703533272, 0.9900757734923491]\n [0.520051568171863, 0.06984731462064464, 0.5529582754578751]\n```\n:::\n:::\n\n\nThis works, but the fill syntax is so nice and short in comparison.\nAlso it gets even worse if you are iterating multiple dimensions in nested for loops, while you can always write `fill(rand(3), 3, 4, 5)`.\n\nSo can we write a macro that makes a list comprehension expression out of a call like `@fill(rand(3), 5)`, so that the first argument is executed anew in each iteration?\nLet's try it!\n\nThe first step is always to understand what expression you're even trying to build.\nWe already use two iterators here to understand how multiple are handled in the resulting expression:\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\nMeta.@dump [rand(3) for _ in 1:5, _ in 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpr\n  head: Symbol comprehension\n  args: Array{Any}((1,))\n    1: Expr\n      head: Symbol generator\n      args: Array{Any}((3,))\n        1: Expr\n          head: Symbol call\n          args: Array{Any}((2,))\n            1: Symbol rand\n            2: Int64 3\n        2: Expr\n          head: Symbol =\n          args: Array{Any}((2,))\n            1: Symbol _\n            2: Expr\n              head: Symbol call\n              args: Array{Any}((3,))\n                1: Symbol :\n                2: Int64 1\n                3: Int64 5\n        3: Expr\n          head: Symbol =\n          args: Array{Any}((2,))\n            1: Symbol _\n            2: Expr\n              head: Symbol call\n              args: Array{Any}((3,))\n                1: Symbol :\n                2: Int64 1\n                3: Int64 3\n```\n:::\n:::\n\n\nAha, now we actually see some real expressions.\nEvery `Expr` object has a `head` that stores what kind of expression it is, and a vector called `args` which contains all arguments to that expression.\n\nWe can see that a list comprehension is made by making an `Expr` where the head is `:comprehension`.\nThere's only one argument to that expression, which is a `:generator` expression.\nThis one in turn is assembled of the expression being called in each iteration, and the iteration expressions `_ = 1:5` and `_ = 1:3`.\n\nWe want to use the syntax `@fill(rand(3), sizes...)`, so we need to think how we can transform those two arguments into the expression we want.\n\nHere, we'll build the `Expr` by hand, instead of writing one big `quote`.\nSometimes that is easier, it also depends on what you find more readable.\nExpressions with a lot of quoting and interpolating can be hard to understand.\nI usually prefer `quote ... end` over the equivalent `:(...)` just because I can parse words a bit better than parentheses.\n\nHere we go:\n\nFor each size argument, we make one of the iterator expressions that we saw in the dump above.\nWe escape each size variable `s` because those are the arguments that the user will write themselves, and they need to resolve correctly in their scope later.\n\nThe comprehension expression then receives the first argument escaped because that expression also needs to run as-is in the user's scope.\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\nmacro fill(exp, sizes...)\n   \n    iterator_expressions = map(sizes) do s\n        Expr(\n            :(=),\n            :_,\n            quote 1:$(esc(s)) end\n        )\n    end\n    \n    Expr(\n        :comprehension,\n        esc(exp),\n        iterator_expressions...\n    )\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n@fill (macro with 1 method)\n```\n:::\n:::\n\n\nLet's try it out:\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n@fill(rand(3), 5)\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n5-element Vector{Vector{Float64}}:\n [0.23155776289714214, 0.16506850108672544, 0.6975576110978176]\n [0.9321190744533363, 0.7284798945126126, 0.8736131864599121]\n [0.36504661751333844, 0.022691708746904182, 0.5288865087865801]\n [0.8521086358547397, 0.2895922988729154, 0.1456070184114313]\n [0.8720484237531486, 0.21008612789745829, 0.5082683499697537]\n```\n:::\n:::\n\n\nA good check if you've escaped correctly is to pass expressions that reference some local variables.\nThe call will error if you've forgotten to escape any of them:\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\nn = 3\nk = 5\n\n@fill(rand(n), k)\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n5-element Vector{Vector{Float64}}:\n [0.5917157732709782, 0.8755225218366083, 0.4032454673315716]\n [0.6111142681907994, 0.06564154230386965, 0.4591276163618556]\n [0.6521749060007972, 0.26064420556063617, 0.2085548309582519]\n [0.64546352947466, 0.485066158128166, 0.20739815115743743]\n [0.8058584624008102, 0.9168621696136154, 0.4280967575910163]\n```\n:::\n:::\n\n\nThis works fine!\nIt should also work with more size arguments, we'll generate only random scalars so the printout is manageable:\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n@fill(rand(), 5, 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n5×3 Matrix{Float64}:\n 0.144371   0.952823    0.331021\n 0.289901   0.00354794  0.822716\n 0.233857   0.810845    0.933876\n 0.665742   0.988701    0.133996\n 0.0806734  0.270098    0.825293\n```\n:::\n:::\n\n\nEven though this particular example is contrived for simplicity (we could just use `rand(5, 3` of course)\ncompare it to the alternative list comprehension syntax:\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\n[rand() for _ in 1:5, _ in 1:3]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n5×3 Matrix{Float64}:\n 0.603045   0.63075   0.313092\n 0.624411   0.835403  0.194775\n 0.924256   0.944286  0.145364\n 0.541554   0.571108  0.120784\n 0.0716549  0.75666   0.619488\n```\n:::\n:::\n\n\n## Summary\n\nAs you can see, macros can be a gain in syntax clarity, and they offer a powerful way to interact with the user's source code.\n\nJust remember that a reader also needs to understand what's happening.\nIn our example, `rand()` is not just executed once but many times, which is non-standard behavior for something resembling a function call.\nThis code-reasoning overhead must always be weighed against the convenience of shorter syntax.\n\nI hope you have learned a thing or two about macros and are encouraged to play around with them yourself.\nUsually, good ideas for macros only present themselves after interacting with Julia for a while, so if you are a beginner,\ngive it time and become proficient with normal functions first.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}