{
  "hash": "688842840bafd6f27714d5d02405f4e7",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Recreating the Makie logo with Luxor.jl\ndate: 2024-05-04\nengine: julia\ncategories: [\"julia\"]\n---\n\nThis is the logo of Makie.jl:\n\n![](makie_icon.svg){width=\"40%\"}\n\nI designed it by hand in a vector graphics editor a couple years ago, however, I always wanted to have a programmatic version of it.\n\nFirst of all, because with a program it's easier to make variations of it or play with it, for example to make animations.\nThe other reason was that the original vector graphics file always seemed a bit large for what it was, at 118KB.\nThe gradient mesh from the editor is flattened to a relatively large inline image for SVG, because SVG doesn't support meshes.\nI wanted to have a programmatic version where I could make this image as small as possible while still looking good.\n\nI decided to make it with [Luxor.jl](https://github.com/JuliaGraphics/Luxor.jl) because it's a relatively thin wrapper around Cairo and nicely documented.\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Luxor\nusing Colors\nusing LinearAlgebra\n```\n:::\n\n\n\nThe basic structure of the logo is a simple cube consisting of three diamonds because Makie is a 3D visualization package.\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n    scale(150, -150)\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.((p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        move(p1)\n        line(p2)\n        line(p3)\n        line(p4)\n        closepath()\n        strokepath()\n    end\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n\nNext, we move each diamond outwards, which gives the cube an \"exploded\" look.\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        move(p1)\n        line(p2)\n        line(p3)\n        line(p4)\n        closepath()\n        strokepath()\n    end\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n\nNow we have to round the corners of the diamonds to make them more petal-like (the petals are a reference to the floral patterns sometimes seen with the Maki-e painting technique).\n\nTo get rounded corners, we need a function which takes in three points that form the sharp corner plus a radius, and calculates where the circular arc with that radius is connected to the adjacent line segments.\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction rounded_corner(p1, p2, p3, radius)\n    d1 = p2 - p1\n    d1_ortho = normalize(Point(-d1.y, d1.x))\n    d2 = p3 - p2\n    d2_ortho = normalize(Point(-d2.y, d2.x))\n\n    _, circle_center = Luxor.intersectionlines(\n        p1 + radius * d1_ortho,\n        p2 + radius * d1_ortho,\n        p2 + radius * d2_ortho,\n        p3 + radius * d2_ortho,\n    )\n\n    circle_center\n    start = circle_center - radius * d1_ortho\n    stop = circle_center - radius * d2_ortho\n\n    circle_center, start, stop\n    arc2r(circle_center, start, stop)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nrounded_corner (generic function with 1 method)\n```\n:::\n:::\n\n\n\nHere's an example of such a rounded corner, the dotted lines show the original sharp corner.\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n    scale(150, -150)\n\n    p1 = Point(-0.3, -0.6)\n    p2 = Point(0.5, 0.8)\n    p3 = Point(-0.5, 0.3)\n    r = 0.1\n\n    move(p1)\n    rounded_corner(p1, p2, p3, r)\n    line(p3)\n    sethue(\"black\")\n    setopacity(0.5)\n    strokepath()\n\n    setdash(\"dot\")\n\n    move(p1)\n    line(p2)\n    strokepath()\n    move(p2)\n    line(p3)\n    strokepath()\n\n    sethue(\"red\")\n    circle(p1, 0.03, :fill)\n    circle(p2, 0.03, :fill)\n    circle(p3, 0.03, :fill)\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n\nNow, we can apply different corner radii to the diamonds and turn them into petals.\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        rounded_corner(p2, p3, p4, 0.06)\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n        strokepath()\n    end\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-7-output-1.svg){}\n:::\n:::\n\n\n\nThere are three negative-space circles cut out of the petals.\nThey resemble scatter plot markers and are a nod to the three circle logo of the Julia language.\n\nWe can first visualize their location by drawing them on top of what we already have.\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        rounded_corner(p2, p3, p4, 0.06)\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n        strokepath()\n\n        circle(cs[i], rs[i], :stroke)\n    end\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-8-output-1.svg){}\n:::\n:::\n\n\n\nWe can now intersect each petal with its two adjacent circles and draw the corresponding circular arcs.\nWith that, we are done with the shape of the logo.\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        c1 = cs[mod1(i + 1, 3)]\n        c2 = cs[mod1(i + 0, 3)]\n\n        n, ip1, ip2 = intersectionlinecircle(p2, p3, c1, rs[mod1(i + 1, 3)])\n        if n != 2\n            error()\n        end\n        n, ip3, ip4 = intersectionlinecircle(p3, p4, c2, rs[mod1(i + 0, 3)])\n        if n != 2\n            error()\n        end\n\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        line(ip2)\n        carc2r(c1, ip2, ip1)\n\n        rounded_corner(p2, p3, p4, 0.06)\n        line(ip4)\n        carc2r(c2, ip4, ip3)\n\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n        strokepath()\n    end\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-9-output-1.svg){}\n:::\n:::\n\n\n\nThe coloring actually needed a bit more thought, because in the original this was done in a messy, freehand way with a four-cornered mesh gradient, two corners of which I overlaid to simulate a triangular shape.\nFirst I didn't have an idea how to transform the three Makie colors into a similar gradient programmatically, linear and radial gradients which are inbuilt into SVG do not work.\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\nmakieyellow = colorant\"#e8cb26\"\nmakieblue = colorant\"#3182bb\"\nmakiered = colorant\"#dd3366\"\n\n[makieyellow, makieblue, makiered]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n\nThen I realized that there's a pretty obvious way to compute the mixture of the colors, just use the same math that shaders use to combine vertex colors of triangles in a mesh, which is what Makie itself does.\nThis is called [barycentric interpolation](https://en.wikipedia.org/wiki/Barycentric_coordinate_system).\n\nThis function computes barycentric weights for three vertices given some point `p`:\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction bary_weights(p, v1, v2, v3)\n    den = ((v2[2] - v3[2]) * (v1[1] - v3[1]) + (v3[1] - v2[1]) * (v1[2] - v3[2]))\n    w1 = ((v2[2] - v3[2]) * (p[1] - v3[1]) + (v3[1] - v2[1]) * (p[2] - v3[2])) / den\n    w2 = ((v3[2] - v1[2]) * (p[1] - v3[1]) + (v1[1] - v3[1]) * (p[2] - v3[2])) / den\n    w3 = 1 - w1 - w2\n    (w1, w2, w3)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nbary_weights (generic function with 1 method)\n```\n:::\n:::\n\n\n\nWe also need some function to mix three rgb colors together, I only found `weighted_color_mean` in Colors.jl which could only handle two colors, so I wrote some separate function which I don't remember why it ended up looking this complex.\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\n_tuple(l::Lab) = (l.l, l.a, l.b)\n_tuple(r::RGB) = (r.r, r.g, r.b)\n_tuple(l::LCHuv) = (l.l, l.c, l.h)\n\n# could reduce weighted_color_mean with 1/i\nfunction mix(cfs...)\n    T = typeof(first(first(cfs)))\n    isempty(cfs) && return T(RGBf(1, 1, 1))\n    if any(cf -> cf[2] == 0, cfs)\n        mix(filter(cf -> cf[2] != 0, cfs)...)\n    else\n        if length(cfs) == 1\n            return cfs[1][1]\n        else\n            scaled = map(cfs) do (c, f)\n                f .* _tuple(c)\n            end\n            _sum = foldl((a, b) -> a .+ b, scaled)\n            _sum_scaled = _sum ./ sum(last.(cfs))\n            return T(_sum_scaled...)\n        end\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmix (generic function with 1 method)\n```\n:::\n:::\n\n\n\nSo with that, we can give it a first try, we determine the bounding box of the outline and compute barycentrically weighted mixtures of the three Makie colors with vertices placed at the petal corners.\n\nBelow, I just clip that grid to the petal corner triangle so it is easier to see the barycentric mixture.\n\n::: {#24 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        push!(cornerpoints, p1)\n    end\n\n    xrange = range(-1, 1, length=10)\n    yrange = range(-1.2, 0.8, length=10)\n\n    pixels = broadcast(xrange, yrange') do i, j\n        p = Point(i, j)\n        f_yellow, f_blue, f_red = clamp.(bary_weights(p, cornerpoints...), 0, 1)\n        mix(((makieyellow), f_yellow), ((makieblue), f_blue), ((makiered), f_red))\n    end\n\n    move(cornerpoints[1])\n    line.(cornerpoints[2:3])\n    closepath()\n    clip()\n\n    @layer begin\n        translate(first(xrange), first(yrange))\n        scale(1 / length(xrange) * (last(xrange) - first(xrange)), 1 / length(yrange) * (last(yrange) - first(yrange)))\n\n        midx = 0.5 * (first(xrange) + last(xrange))\n        midy = 0.5 * (first(yrange) + last(yrange))\n        placeimage(pixels', O, centered=false)\n    end\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\n\nIf you compare that gradient to the original logo:\n\n![](makie_icon.svg){width=\"40%\"}\n\nYou notice that three Makie colors take more space there, each petal is mostly one color but fades into the neighboring petal at the edges.\n\nI could solve this by exponentiating the barycentric weights.\nI experimented with different numbers and arrived at 2.1 as a pretty good fit.\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        push!(cornerpoints, p1)\n    end\n\n    xrange = range(-1, 1, length=10)\n    yrange = range(-1.2, 0.8, length=10)\n\n    pixels = broadcast(xrange, yrange') do i, j\n        p = Point(i, j)\n        f_yellow, f_blue, f_red = clamp.(bary_weights(p, cornerpoints...), 0, 1) .^ 2.1\n        mix(((makieyellow), f_yellow), ((makieblue), f_blue), ((makiered), f_red))\n    end\n\n    move(cornerpoints[1])\n    line.(cornerpoints[2:3])\n    closepath()\n    clip()\n\n    @layer begin\n        translate(first(xrange), first(yrange))\n        scale(1 / length(xrange) * (last(xrange) - first(xrange)), 1 / length(yrange) * (last(yrange) - first(yrange)))\n\n        midx = 0.5 * (first(xrange) + last(xrange))\n        midy = 0.5 * (first(yrange) + last(yrange))\n        placeimage(pixels', O, centered=false)\n    end\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-14-output-1.svg){}\n:::\n:::\n\n\n\nAnd this is how that triangle looks overlaid on the logo outline:\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        c1 = cs[mod1(i + 1, 3)]\n        c2 = cs[mod1(i + 0, 3)]\n\n        n, ip1, ip2 = intersectionlinecircle(p2, p3, c1, rs[mod1(i + 1, 3)])\n        if n != 2\n            error()\n        end\n        n, ip3, ip4 = intersectionlinecircle(p3, p4, c2, rs[mod1(i + 0, 3)])\n        if n != 2\n            error()\n        end\n\n        push!(cornerpoints, p1)\n\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        line(ip2)\n        carc2r(c1, ip2, ip1)\n\n        rounded_corner(p2, p3, p4, 0.06)\n        line(ip4)\n        carc2r(c2, ip4, ip3)\n\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n\n    end\n\n    path = pathtopoly()\n\n    strokepath()\n\n    move(cornerpoints[1])\n    line.(cornerpoints[2:3])\n    closepath()\n    clip()\n\n    xrange = range(extrema(x -> x.x, Iterators.flatten(path))..., length=10)\n    yrange = range(extrema(x -> x.y, Iterators.flatten(path))..., length=10)\n\n    pixels = broadcast(xrange, yrange') do i, j\n        p = Point(i, j)\n        f_yellow, f_blue, f_red = clamp.(bary_weights(p, cornerpoints...), 0, 1) .^ 2.1\n        mix(((makieyellow), f_yellow), ((makieblue), f_blue), ((makiered), f_red))\n    end\n\n    translate(first(xrange), first(yrange))\n    scale(1 / length(xrange) * (last(xrange) - first(xrange)), 1 / length(yrange) * (last(yrange) - first(yrange)))\n\n    midx = 0.5 * (first(xrange) + last(xrange))\n    midy = 0.5 * (first(yrange) + last(yrange))\n    placeimage(pixels', O, centered=false)\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-15-output-1.svg){}\n:::\n:::\n\n\n\nTo arrive at the final result, I simply remove the triangle and switch the logo shape from a stroked outline to a clipping mask for the full gradient mesh.\nOutside of the triangle negative barycentric weights are simply clipped to zero.\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n@drawsvg begin\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(150, -150)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        c1 = cs[mod1(i + 1, 3)]\n        c2 = cs[mod1(i + 0, 3)]\n\n        n, ip1, ip2 = intersectionlinecircle(p2, p3, c1, rs[mod1(i + 1, 3)])\n        if n != 2\n            error()\n        end\n        n, ip3, ip4 = intersectionlinecircle(p3, p4, c2, rs[mod1(i + 0, 3)])\n        if n != 2\n            error()\n        end\n\n        push!(cornerpoints, p1)\n\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        line(ip2)\n        carc2r(c1, ip2, ip1)\n\n        rounded_corner(p2, p3, p4, 0.06)\n        line(ip4)\n        carc2r(c2, ip4, ip3)\n\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n\n    end\n\n    path = pathtopoly()\n\n    clip()\n\n    xrange = range(extrema(x -> x.x, Iterators.flatten(path))..., length=10)\n    yrange = range(extrema(x -> x.y, Iterators.flatten(path))..., length=10)\n\n    pixels = broadcast(xrange, yrange') do i, j\n        p = Point(i, j)\n        f_yellow, f_blue, f_red = clamp.(bary_weights(p, cornerpoints...), 0, 1) .^ 2.1\n        mix(((makieyellow), f_yellow), ((makieblue), f_blue), ((makiered), f_red))\n    end\n\n    translate(first(xrange), first(yrange))\n    scale(1 / length(xrange) * (last(xrange) - first(xrange)), 1 / length(yrange) * (last(yrange) - first(yrange)))\n\n    midx = 0.5 * (first(xrange) + last(xrange))\n    midy = 0.5 * (first(yrange) + last(yrange))\n    placeimage(pixels', O, centered=false)\n\nend 400 400\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](index_files/figure-html/cell-16-output-1.svg){}\n:::\n:::\n\n\n\nAnd that's it!\nWe can compare once more to the original:\n\n![](makie_icon.svg){width=\"40%\"}\n\nI think that's a pretty good match, and the size of the new version is just 3KB with a 10x10 pixel gradient.\n\nFinally, I have to do one animation, just because I can do it now!\n\n::: {#32 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nfunction frame(scene, framenumber)\n\n    background(\"white\")\n\n    inner_gap = 0.045 / cosd(30)\n\n    scale(250, -250)\n\n    cornerpoints = []\n\n    cs = [\n        Point(0, 0.45),\n        rotatepoint(Point(0, 0.45), 2pi / 3),\n        rotatepoint(Point(0, 0.45), 2 * 2pi / 3),\n    ]\n    rs = [0.15, 0.235, 0.195]\n\n    for i in 1:3\n        p1 = Point(1, 0)\n        p3 = Point(0, 0)\n        p2 = Point(0.5, sqrt(3) / 2)\n        p4 = Point(0.5, -sqrt(3) / 2)\n\n        (p1, p2, p3, p4) = rotatepoint.(Point(inner_gap, 0) .+ (p1, p2, p3, p4), i * 2pi / 3 + 2pi / 12)\n\n        c1 = cs[mod1(i + 1, 3)]\n        c2 = cs[mod1(i + 0, 3)]\n\n        n, ip1, ip2 = intersectionlinecircle(p2, p3, c1, rs[mod1(i + 1, 3)])\n        if n != 2\n            error()\n        end\n        n, ip3, ip4 = intersectionlinecircle(p3, p4, c2, rs[mod1(i + 0, 3)])\n        if n != 2\n            error()\n        end\n\n        push!(cornerpoints, rotatepoint(p1, (framenumber - 1) / 99 * 2pi))\n\n\n        move(p1)\n        rounded_corner(p1, p2, p3, 0.17)\n        line(ip2)\n        carc2r(c1, ip2, ip1)\n\n        rounded_corner(p2, p3, p4, 0.06)\n        line(ip4)\n        carc2r(c2, ip4, ip3)\n\n        rounded_corner(p3, p4, p1, 0.17)\n        closepath()\n\n\n    end\n\n    path = pathtopoly()\n\n    clip()\n\n    xrange = range(extrema(x -> x.x, Iterators.flatten(path))..., length=50)\n    yrange = range(extrema(x -> x.y, Iterators.flatten(path))..., length=50)\n\n    pixels = broadcast(xrange, yrange') do i, j\n        p = Point(i, j)\n        f_yellow, f_blue, f_red = clamp.(bary_weights(p, cornerpoints...), 0, 1) .^ 2.1\n        mix(((makieyellow), f_yellow), ((makieblue), f_blue), ((makiered), f_red))\n    end\n\n    translate(first(xrange), first(yrange))\n    scale(1 / length(xrange) * (last(xrange) - first(xrange)), 1 / length(yrange) * (last(yrange) - first(yrange)))\n\n    midx = 0.5 * (first(xrange) + last(xrange))\n    midy = 0.5 * (first(yrange) + last(yrange))\n    placeimage(pixels', O, centered=false)\n\nend\n\nmovie = Movie(600, 600, \"makielogo\")\n\nmktempdir() do dir\n    animate(movie, [Scene(movie, frame, 0:100)]; tempdirectory = dir)\n    run(`ffmpeg -i $(dir)/%10d.png -y -pix_fmt yuv420p -c:v libx264 -movflags +faststart -filter:v crop='floor(in_w/2)*2:floor(in_h/2)*2' makie.mp4`)\nend\n```\n:::\n\n\n\n{{< video makie.mp4 width=\"300\" height=\"300\" >}}\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": []
  }
}